# HG changeset patch
# Parent a7dea879b4b445a23186f438900562155bb39e99
Bug 620931 part 1 - Use chrome manifest to register resource://gre-resources/

diff --git a/layout/style/jar.mn b/layout/style/jar.mn
--- a/layout/style/jar.mn
+++ b/layout/style/jar.mn
@@ -1,8 +1,10 @@
 toolkit.jar:
 *  res/ua.css    (ua.css)
    res/html.css    (html.css)
    res/quirk.css    (quirk.css)
    res/viewsource.css    (viewsource.css)
 *  res/forms.css    (forms.css)
    res/arrow.gif    (arrow.gif)
    res/arrowd.gif   (arrowd.gif)
+
+% resource gre-resources %res/
diff --git a/netwerk/protocol/res/nsResProtocolHandler.cpp b/netwerk/protocol/res/nsResProtocolHandler.cpp
--- a/netwerk/protocol/res/nsResProtocolHandler.cpp
+++ b/netwerk/protocol/res/nsResProtocolHandler.cpp
@@ -75,17 +75,16 @@ static nsResProtocolHandler *gResHandler
 //
 // this enables PR_LOG_ALWAYS level information and places all output in
 // the file log.txt
 //
 static PRLogModuleInfo *gResLog;
 #endif
 
 #define kGRE           NS_LITERAL_CSTRING("gre")
-#define kGRE_RESOURCES NS_LITERAL_CSTRING("gre-resources")
 
 //----------------------------------------------------------------------------
 // nsResURL : overrides nsStandardURL::GetFile to provide nsIFile resolution
 //----------------------------------------------------------------------------
 
 nsresult
 nsResURL::EnsureFile()
 {
@@ -197,28 +196,16 @@ nsResProtocolHandler::Init()
     NS_ENSURE_SUCCESS(rv, rv);
 
     //
     // make resource://gre/ point to the GRE directory
     //
     rv = AddSpecialDir(NS_GRE_DIR, kGRE);
     NS_ENSURE_SUCCESS(rv, rv);
 
-    // make resource://gre-resources/ point to gre toolkit[.jar]/res
-    nsCOMPtr<nsIURI> greURI;
-    nsCOMPtr<nsIURI> greResURI;
-    GetSubstitution(kGRE, getter_AddRefs(greURI));
-#ifdef MOZ_CHROME_FILE_FORMAT_JAR
-    NS_NAMED_LITERAL_CSTRING(strGRE_RES_URL, "jar:chrome/toolkit.jar!/res/");
-#else
-    NS_NAMED_LITERAL_CSTRING(strGRE_RES_URL, "chrome/toolkit/res/");
-#endif
-    rv = mIOService->NewURI(strGRE_RES_URL, nsnull, greURI,
-                            getter_AddRefs(greResURI));
-    SetSubstitution(kGRE_RESOURCES, greResURI);
     //XXXbsmedberg Neil wants a resource://pchrome/ for the profile chrome dir...
     // but once I finish multiple chrome registration I'm not sure that it is needed
 
     // XXX dveditz: resource://pchrome/ defeats profile directory salting
     // if web content can load it. Tread carefully.
 
     return rv;
 }
@@ -242,22 +229,16 @@ nsResProtocolHandler::Init(nsIFile *aOmn
     // these entries should be kept in sync with the normal Init function
 
     // resource:/// points to jar:omni.jar!/
     SetSubstitution(EmptyCString(), uri);
 
     // resource://gre/ points to jar:omni.jar!/
     SetSubstitution(kGRE, uri);
 
-    urlStr += "chrome/toolkit/res/";
-    rv = mIOService->NewURI(urlStr, nsnull, nsnull, getter_AddRefs(uri));
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    // resource://gre-resources/ points to jar:omni.jar!/chrome/toolkit/res/
-    SetSubstitution(kGRE_RESOURCES, uri);
     return NS_OK;
 }
 #endif
 
 #ifdef MOZ_IPC
 static PLDHashOperator
 EnumerateSubstitution(const nsACString& aKey,
                       nsIURI* aURI,
# HG changeset patch
# Parent 3038cccba1a071d6b418e15442d0f2d9f3dcb11d
Bug 620931 part 2 - When building --with-libxul-sdk, use the right preferences directory

diff --git a/browser/locales/Makefile.in b/browser/locales/Makefile.in
--- a/browser/locales/Makefile.in
+++ b/browser/locales/Makefile.in
@@ -183,17 +183,17 @@ install:: $(addsuffix .xml,$(SEARCH_PLUG
 	$(SYSINSTALL) $(IFLAGS1) $^ $(DESTDIR)$(mozappdir)/searchplugins
 
 
 libs-%:
 	$(NSINSTALL) -D $(DIST)/install
 	@$(MAKE) -C ../../toolkit/locales libs-$* BOTH_MANIFESTS=1
 	@$(MAKE) -C ../../services/sync/locales AB_CD=$* XPI_NAME=locale-$* BOTH_MANIFESTS=1
 	@$(MAKE) -C ../../extensions/spellcheck/locales AB_CD=$* XPI_NAME=locale-$* BOTH_MANIFESTS=1
-	@$(MAKE) libs AB_CD=$* XPI_NAME=locale-$* PREF_DIR=defaults/pref BOTH_MANIFESTS=1
+	@$(MAKE) libs AB_CD=$* XPI_NAME=locale-$* PREF_DIR=$(PREF_DIR) BOTH_MANIFESTS=1
 	@$(MAKE) -C $(DEPTH)/$(MOZ_BRANDING_DIRECTORY)/locales AB_CD=$* XPI_NAME=locale-$* BOTH_MANIFESTS=1
 
 
 repackage-win32-installer: WIN32_INSTALLER_OUT="$(_ABS_DIST)/$(PKG_INST_PATH)$(PKG_INST_BASENAME).exe"
 repackage-win32-installer: $(WIN32_INSTALLER_IN) $(SUBMAKEFILES)
 	@echo "Repackaging $(WIN32_INSTALLER_IN) into $(WIN32_INSTALLER_OUT)."
 	$(MAKE) -C $(DEPTH)/$(MOZ_BRANDING_DIRECTORY) export
 	$(MAKE) -C ../installer/windows CONFIG_DIR=l10ngen l10ngen/setup.exe l10ngen/7zSD.sfx
diff --git a/toolkit/mozapps/installer/packager.mk b/toolkit/mozapps/installer/packager.mk
--- a/toolkit/mozapps/installer/packager.mk
+++ b/toolkit/mozapps/installer/packager.mk
@@ -307,17 +307,17 @@ OMNIJAR_FILES	= \
   res \
   defaults \
   greprefs.js \
   jsloader \
   $(NULL)
 
 NON_OMNIJAR_FILES += \
   chrome/icons/\* \
-  defaults/pref/channel-prefs.js \
+  $(PREF_DIR)/channel-prefs.js \
   res/cursors/\* \
   res/MainMenu.nib/\* \
   $(NULL)
 
 PACK_OMNIJAR	= \
   rm -f omni.jar components/binary.manifest && \
   grep -h '^binary-component' components/*.manifest > binary.manifest ; \
   sed -e 's/^binary-component/\#binary-component/' components/components.manifest > components.manifest && \
# HG changeset patch
# Parent cd8df8030f7ad7530692bd7c4391a8009df56a02
Bug 620931 part 3 - Allow GRE and XUL application to use omni.jar independently

We now store two independent locations for an omni.jar, allowing GRE/XRE and
XUL application to each have their own omni.jar. And since xulrunner setups
are very independent from the XUL applications, we implement support for both
omni.jar and non omni.jar cases in the same runtime, with the side effect of
allowing to switch from one to the other manually without rebuilding the
binaries.

We let the mozilla::Omnijar API handle both cases, so that callers don't need
too much work to support them.

We also make the preferences service load the same set of preferences in all
the various cases (unified vs. separate, omni.jar vs. no omni.jar).

The child process launcher for IPC is modified to pass the base directories
needed for the mozilla::Omnijar API initialization in the child process.

Finally, the startupcache file name canonicalization is modified to separate
APP and GRE resources.

diff --git a/ipc/glue/GeckoChildProcessHost.cpp b/ipc/glue/GeckoChildProcessHost.cpp
--- a/ipc/glue/GeckoChildProcessHost.cpp
+++ b/ipc/glue/GeckoChildProcessHost.cpp
@@ -440,26 +440,29 @@ GeckoChildProcessHost::PerformAsyncLaunc
   // other end of the socketpair() from us
 
   std::vector<std::string> childArgv;
 
   childArgv.push_back(exePath.value());
 
   childArgv.insert(childArgv.end(), aExtraOpts.begin(), aExtraOpts.end());
 
-#ifdef MOZ_OMNIJAR
   // Make sure the child process can find the omnijar
   // See XRE_InitCommandLine in nsAppRunner.cpp
-  nsCAutoString omnijarPath;
-  if (mozilla::OmnijarPath()) {
-    mozilla::OmnijarPath()->GetNativePath(omnijarPath);
-    childArgv.push_back("-omnijar");
-    childArgv.push_back(omnijarPath.get());
+  nsCAutoString path;
+  nsCOMPtr<nsIFile> file = mozilla::Omnijar::GetBase(mozilla::Omnijar::GRE);
+  if (file && NS_SUCCEEDED(file->GetNativePath(path))) {
+    childArgv.push_back("-grebase");
+    childArgv.push_back(path.get());
   }
-#endif
+  file = mozilla::Omnijar::GetBase(mozilla::Omnijar::APP);
+  if (file && NS_SUCCEEDED(file->GetNativePath(path))) {
+    childArgv.push_back("-appbase");
+    childArgv.push_back(path.get());
+  }
 
   childArgv.push_back(pidstring);
 
 #if defined(MOZ_CRASHREPORTER)
 #  if defined(OS_LINUX)
   int childCrashFd, childCrashRemapFd;
   if (!CrashReporter::CreateNotificationPipeForChild(
         &childCrashFd, &childCrashRemapFd))
@@ -552,26 +555,29 @@ GeckoChildProcessHost::PerformAsyncLaunc
   for (std::vector<std::string>::iterator it = aExtraOpts.begin();
        it != aExtraOpts.end();
        ++it) {
       cmdLine.AppendLooseValue(UTF8ToWide(*it));
   }
 
   cmdLine.AppendLooseValue(std::wstring(mGroupId.get()));
 
-#ifdef MOZ_OMNIJAR
   // Make sure the child process can find the omnijar
   // See XRE_InitCommandLine in nsAppRunner.cpp
-  nsAutoString omnijarPath;
-  if (mozilla::OmnijarPath()) {
-    mozilla::OmnijarPath()->GetPath(omnijarPath);
-    cmdLine.AppendLooseValue(UTF8ToWide("-omnijar"));
-    cmdLine.AppendLooseValue(omnijarPath.get());
+  nsAutoString path;
+  nsCOMPtr<nsIFile> file = mozilla::Omnijar::GetBase(mozilla::Omnijar::GRE);
+  if (file && NS_SUCCEEDED(file->GetPath(path))) {
+    cmdLine.AppendLooseValue(UTF8ToWide("-grebase"));
+    cmdLine.AppendLooseValue(path.get());
   }
-#endif
+  file = mozilla::Omnijar::GetBase(mozilla::Omnijar::APP);
+  if (file && NS_SUCCEEDED(file->GetPath(path))) {
+    cmdLine.AppendLooseValue(UTF8ToWide("-appbase"));
+    cmdLine.AppendLooseValue(path.get());
+  }
 
   cmdLine.AppendLooseValue(UTF8ToWide(pidstring));
 
 #if defined(MOZ_CRASHREPORTER)
   cmdLine.AppendLooseValue(
     UTF8ToWide(CrashReporter::GetChildNotificationPipe()));
 #endif
 
diff --git a/js/src/xpconnect/loader/mozJSComponentLoader.cpp b/js/src/xpconnect/loader/mozJSComponentLoader.cpp
--- a/js/src/xpconnect/loader/mozJSComponentLoader.cpp
+++ b/js/src/xpconnect/loader/mozJSComponentLoader.cpp
@@ -81,16 +81,17 @@
 #include "nsIConsoleService.h"
 #include "nsIStorageStream.h"
 #include "nsIStringStream.h"
 #include "prmem.h"
 #if defined(XP_WIN)
 #include "nsILocalFileWin.h"
 #endif
 #include "xpcprivate.h"
+#include "nsIResProtocolHandler.h"
 
 #ifdef MOZ_ENABLE_LIBXUL
 #include "mozilla/scache/StartupCache.h"
 #include "mozilla/scache/StartupCacheUtils.h"
 #endif
 #include "mozilla/Omnijar.h"
 
 #include "jsdbgapi.h"
@@ -621,34 +622,21 @@ mozJSComponentLoader::LoadModule(nsILoca
 
 const mozilla::Module*
 mozJSComponentLoader::LoadModuleFromJAR(nsILocalFile *aJarFile,
                                         const nsACString &aComponentPath)
 {
 #if !defined(XPCONNECT_STANDALONE)
     nsresult rv;
 
-    nsCAutoString fullSpec;
-
-#ifdef MOZ_OMNIJAR
-    PRBool equal;
-    rv = aJarFile->Equals(mozilla::OmnijarPath(), &equal);
-    if (NS_SUCCEEDED(rv) && equal) {
-        fullSpec = "resource://gre/";
-    } else {
-#endif
-        nsCAutoString fileSpec;
-        NS_GetURLSpecFromActualFile(aJarFile, fileSpec);
-        fullSpec = "jar:";
-        fullSpec += fileSpec;
-        fullSpec += "!/";
-#ifdef MOZ_OMNIJAR
-    }
-#endif
-
+    nsCAutoString fullSpec, fileSpec;
+    NS_GetURLSpecFromActualFile(aJarFile, fileSpec);
+    fullSpec = "jar:";
+    fullSpec += fileSpec;
+    fullSpec += "!/";
     fullSpec += aComponentPath;
 
     nsCOMPtr<nsIURI> uri;
     rv = NS_NewURI(getter_AddRefs(uri), fullSpec);
     if (NS_FAILED(rv))
         return NULL;
 
     nsAutoString hashstring;
@@ -833,57 +821,138 @@ class JSScriptHolder
     JSScriptHolder(JSContext *cx, JSScript *script)
         : mCx(cx), mScript(script) {}
     ~JSScriptHolder() { ::JS_DestroyScript(mCx, mScript); }
  private:
     JSContext *mCx;
     JSScript *mScript;
 };
 
+static const char baseName[2][5] = { "gre/", "app/" };
+
+static inline PRBool
+canonicalizeBase(nsCAutoString &spec, nsACString &out, mozilla::Omnijar::Type aType)
+{
+    nsCAutoString base;
+    nsresult rv = mozilla::Omnijar::GetURIString(aType, base);
+
+    if (NS_FAILED(rv) || !base.Length())
+        return PR_FALSE;
+
+    if (base.Compare(spec.get(), PR_FALSE, base.Length()))
+        return PR_FALSE;
+
+    out.Append("/resource/");
+    out.Append(baseName[aType]);
+    out.Append(Substring(spec, base.Length()));
+    return PR_TRUE;
+}
 /**
  * PathifyURI transforms mozilla .js uris into useful zip paths
  * to make it makes it easier to manipulate startup cache entries
  * using standard zip tools.
  * Transformations applied:
- *  * jsloader/<scheme> prefix is used to group mozJSComponentLoader cache entries in
+ *  * jsloader/ prefix is used to group mozJSComponentLoader cache entries in
  *    a top-level zip directory.
- *  * In MOZ_OMNIJAR case resource:/// and resource://gre/ URIs refer to the same path
- *    so treat both of them as resource://gre/
+ *  * resource:// URIs are resolved to their corresponding file/jar URI to
+ *    canonicalize resources URIs other than gre and app.
+ *  * Paths under GRE or APP directory have their base path replaced with
+ *    resource/gre or resource/app to avoid depending on install location.
+ *  * jar:file:///path/to/file.jar!/sub/path urls are replaced with
+ *    /path/to/file.jar/sub/path
  *  * .bin suffix is added to the end of the path to indicate that jsloader/ entries
  *     are binary representations of JS source.
  * For example:
- *  resource://gre/modules/XPCOMUtils.jsm becomes
- *  jsloader/resource/gre/modules/XPCOMUtils.jsm.bin
+ *  resource://gre/modules/XPCOMUtils.jsm or
+ *  file://$GRE_DIR/modules/XPCOMUtils.jsm or
+ *  jar:file://$GRE_DIR/omni.jar!/modules/XPCOMUtils.jsm become
+ *     jsloader/resource/gre/modules/XPCOMUtils.jsm.bin
+ *  file://$PROFILE_DIR/extensions/{uuid}/components/component.js becomes
+ *     jsloader/$PROFILE_DIR/extensions/%7Buuid%7D/components/component.js.bin
+ *  jar:file://$PROFILE_DIR/extensions/some.xpi!/components/component.js becomes
+ *     jsloader/$PROFILE_DIR/extensions/some.xpi/components/component.js.bin
  */
 static nsresult
 PathifyURI(nsIURI *in, nsACString &out)
 { 
-   out = "jsloader/";
-   nsCAutoString scheme;
-   nsresult rv = in->GetScheme(scheme);
-   NS_ENSURE_SUCCESS(rv, rv);
-   out.Append(scheme);
-   nsCAutoString host;
-   // OK for GetHost to fail since it's not implemented sometimes
-   in->GetHost(host);
-#ifdef MOZ_OMNIJAR
-   if (scheme.Equals("resource") && host.Length() == 0){
-       host = "gre";
-   }
-#endif
-   if (host.Length()) {
-       out.Append("/");
-       out.Append(host);
-   }
-   nsCAutoString path;
-   rv = in->GetPath(path);
-   NS_ENSURE_SUCCESS(rv, rv);
-   out.Append(path);
-   out.Append(".bin");
-   return NS_OK;
+    PRBool equals;
+    nsresult rv;
+    nsCOMPtr<nsIURI> uri = in;
+    nsCAutoString spec;
+
+    out = "jsloader";
+
+    // Resolve resource:// URIs. At the end of this if/else block, we
+    // have both spec and uri variables identifying the same URI.
+    if (NS_SUCCEEDED(in->SchemeIs("resource", &equals)) && equals) {
+        nsCOMPtr<nsIIOService> ioService = do_GetIOService(&rv);
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        nsCOMPtr<nsIProtocolHandler> ph;
+        rv = ioService->GetProtocolHandler("resource", getter_AddRefs(ph));
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        nsCOMPtr<nsIResProtocolHandler> irph(do_QueryInterface(ph, &rv));
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        rv = irph->ResolveURI(in, spec);
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        rv = ioService->NewURI(spec, nsnull, nsnull, getter_AddRefs(uri));
+        NS_ENSURE_SUCCESS(rv, rv);
+    } else {
+        rv = in->GetSpec(spec);
+        NS_ENSURE_SUCCESS(rv, rv);
+    }
+
+    if (!canonicalizeBase(spec, out, mozilla::Omnijar::GRE) &&
+        !canonicalizeBase(spec, out, mozilla::Omnijar::APP)) {
+        if (NS_SUCCEEDED(uri->SchemeIs("file", &equals)) && equals) {
+            nsCOMPtr<nsIFileURL> baseFileURL;
+            baseFileURL = do_QueryInterface(uri, &rv);
+            NS_ENSURE_SUCCESS(rv, rv);
+
+            nsCAutoString path;
+            rv = baseFileURL->GetPath(path);
+            NS_ENSURE_SUCCESS(rv, rv);
+
+            out.Append(path);
+        } else if (NS_SUCCEEDED(uri->SchemeIs("jar", &equals)) && equals) {
+            nsCOMPtr<nsIJARURI> jarURI = do_QueryInterface(uri, &rv);
+            NS_ENSURE_SUCCESS(rv, rv);
+
+            nsCOMPtr<nsIURI> jarFileURI;
+            rv = jarURI->GetJARFile(getter_AddRefs(jarFileURI));
+            NS_ENSURE_SUCCESS(rv, rv);
+
+            nsCOMPtr<nsIFileURL> jarFileURL;
+            jarFileURL = do_QueryInterface(jarFileURI, &rv);
+            NS_ENSURE_SUCCESS(rv, rv);
+
+            nsCAutoString path;
+            rv = jarFileURL->GetPath(path);
+            NS_ENSURE_SUCCESS(rv, rv);
+            out.Append(path);
+
+            rv = jarURI->GetJAREntry(path);
+            NS_ENSURE_SUCCESS(rv, rv);
+            out.Append("/");
+            out.Append(path);
+        } else { // Very unlikely
+            nsCAutoString spec;
+            rv = uri->GetSpec(spec);
+            NS_ENSURE_SUCCESS(rv, rv);
+
+            out.Append("/");
+            out.Append(spec);
+        }
+    }
+
+    out.Append(".bin");
+    return NS_OK;
 }
 
 /* static */
 #ifdef MOZ_ENABLE_LIBXUL
 nsresult
 mozJSComponentLoader::ReadScript(StartupCache* cache, nsIURI *uri,
                                  JSContext *cx, JSScript **script)
 {
diff --git a/modules/libjar/nsJAR.cpp b/modules/libjar/nsJAR.cpp
--- a/modules/libjar/nsJAR.cpp
+++ b/modules/libjar/nsJAR.cpp
@@ -170,26 +170,23 @@ nsJAR::Open(nsIFile* zipFile)
   NS_ENSURE_ARG_POINTER(zipFile);
   if (mLock) return NS_ERROR_FAILURE; // Already open!
 
   mZipFile = zipFile;
 
   mLock = PR_NewLock();
   NS_ENSURE_TRUE(mLock, NS_ERROR_OUT_OF_MEMORY);
   
-#ifdef MOZ_OMNIJAR
   // The omnijar is special, it is opened early on and closed late
   // this avoids reopening it
-  PRBool equals;
-  nsresult rv = zipFile->Equals(mozilla::OmnijarPath(), &equals);
-  if (NS_SUCCEEDED(rv) && equals) {
-    mZip = mozilla::OmnijarReader();
+  nsZipArchive *zip = mozilla::Omnijar::GetReader(zipFile);
+  if (zip) {
+    mZip = zip;
     return NS_OK;
   }
-#endif
   return mZip->OpenArchive(zipFile);
 }
 
 NS_IMETHODIMP
 nsJAR::OpenInner(nsIZipReader *aZipReader, const char *aZipEntry)
 {
   NS_ENSURE_ARG_POINTER(aZipReader);
   NS_ENSURE_ARG_POINTER(aZipEntry);
@@ -234,23 +231,22 @@ nsJAR::Close()
   }
 
   mParsedManifest = PR_FALSE;
   mManifestData.Reset();
   mGlobalStatus = JAR_MANIFEST_NOT_PARSED;
   mTotalItemsInManifest = 0;
   mOuterZipEntry.Truncate(0);
 
-#ifdef MOZ_OMNIJAR
-  if (mZip == mozilla::OmnijarReader()) {
+  if ((mZip == mozilla::Omnijar::GetReader(mozilla::Omnijar::GRE)) ||
+      (mZip == mozilla::Omnijar::GetReader(mozilla::Omnijar::APP))) {
     mZip.forget();
     mZip = new nsZipArchive();
     return NS_OK;
   }
-#endif
   return mZip->CloseArchive();
 }
 
 NS_IMETHODIMP
 nsJAR::Test(const char *aEntryName)
 {
   return mZip->Test(aEntryName);
 }
@@ -391,22 +387,21 @@ nsJAR::GetInputStreamWithSpec(const nsAC
 NS_IMETHODIMP
 nsJAR::GetCertificatePrincipal(const char* aFilename, nsIPrincipal** aPrincipal)
 {
   //-- Parameter check
   if (!aPrincipal)
     return NS_ERROR_NULL_POINTER;
   *aPrincipal = nsnull;
 
-#ifdef MOZ_OMNIJAR
   // Don't check signatures in the omnijar - this is only
   // interesting for extensions/XPIs.
-  if (mZip == mozilla::OmnijarReader())
+  if ((mZip == mozilla::Omnijar::GetReader(mozilla::Omnijar::GRE)) ||
+      (mZip == mozilla::Omnijar::GetReader(mozilla::Omnijar::APP)))
     return NS_OK;
-#endif
 
   //-- Parse the manifest
   nsresult rv = ParseManifest();
   if (NS_FAILED(rv)) return rv;
   if (mGlobalStatus == JAR_NO_MANIFEST)
     return NS_OK;
 
   PRInt16 requestedStatus;
diff --git a/modules/libpref/src/nsPrefService.cpp b/modules/libpref/src/nsPrefService.cpp
--- a/modules/libpref/src/nsPrefService.cpp
+++ b/modules/libpref/src/nsPrefService.cpp
@@ -67,20 +67,18 @@
 
 #include "prefapi.h"
 #include "prefread.h"
 #include "prefapi_private_data.h"
 #include "PrefTuple.h"
 
 #include "nsITimelineService.h"
 
-#ifdef MOZ_OMNIJAR
 #include "mozilla/Omnijar.h"
 #include "nsZipArchive.h"
-#endif
 
 // Definitions
 #define INITIAL_PREF_FILES 10
 static NS_DEFINE_CID(kZipReaderCID, NS_ZIPREADER_CID);
 
 // Prototypes
 static nsresult openPrefFile(nsIFile* aFile);
 static nsresult pref_InitInitialObjects(void);
@@ -793,124 +791,144 @@ static nsresult pref_LoadPrefsInDirList(
           pref_LoadPrefsInDir(dir, nsnull, 0); 
         }
       }
     }
   }
   return NS_OK;
 }
 
-//----------------------------------------------------------------------------------------
-// Initialize default preference JavaScript buffers from
-// appropriate TEXT resources
-//----------------------------------------------------------------------------------------
-static nsresult pref_InitDefaults()
-{
-  nsCOMPtr<nsIFile> greprefsFile;
-  nsresult          rv;
-
-  rv = NS_GetSpecialDirectory(NS_GRE_DIR, getter_AddRefs(greprefsFile));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  rv = greprefsFile->AppendNative(NS_LITERAL_CSTRING("greprefs.js"));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  rv = openPrefFile(greprefsFile);
-  if (NS_FAILED(rv)) {
-    NS_WARNING("Error parsing GRE default preferences. Is this an old-style embedding app?");
-  }
-
-  return NS_OK;
-}
-
-#ifdef MOZ_OMNIJAR
 static nsresult pref_ReadPrefFromJar(nsZipArchive* jarReader, const char *name)
 {
   nsZipItemPtr<char> manifest(jarReader, name, true);
   NS_ENSURE_TRUE(manifest.Buffer(), NS_ERROR_NOT_AVAILABLE);
 
   PrefParseState ps;
   PREF_InitParseState(&ps, PREF_ReaderCallback, NULL);
   nsresult rv = PREF_ParseBuf(&ps, manifest, manifest.Length());
   PREF_FinalizeParseState(&ps);
 
   return rv;
 }
 
-static nsresult pref_InitAppDefaultsFromOmnijar()
-{
-  nsresult rv;
-
-  nsZipArchive* jarReader = mozilla::OmnijarReader();
-  if (!jarReader)
-    return pref_InitDefaults();
-
-  rv = pref_ReadPrefFromJar(jarReader, "greprefs.js");
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  nsZipFind *findPtr;
-  rv = jarReader->FindInit("defaults/pref/*.js$", &findPtr);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  nsAutoPtr<nsZipFind> find(findPtr);
-
-  nsTArray<nsCString> prefEntries;
-  const char *entryName;
-  PRUint16 entryNameLen;
-  while (NS_SUCCEEDED(find->FindNext(&entryName, &entryNameLen))) {
-    prefEntries.AppendElement(Substring(entryName, entryName + entryNameLen));
-  }
-
-  prefEntries.Sort();
-  for (PRUint32 i = prefEntries.Length(); i--; ) {
-    rv = pref_ReadPrefFromJar(jarReader, prefEntries[i].get());
-    if (NS_FAILED(rv))
-      NS_WARNING("Error parsing preferences.");
-  }
-
-  return NS_OK;
-}
-#endif
-
+//----------------------------------------------------------------------------------------
+// Initialize default preference JavaScript buffers from
+// appropriate TEXT resources
+//----------------------------------------------------------------------------------------
 static nsresult pref_InitInitialObjects()
 {
   nsresult rv;
 
-  // first we parse the GRE default prefs. This also works if we're not using a GRE, 
-#ifdef MOZ_OMNIJAR
-  rv = pref_InitAppDefaultsFromOmnijar();
-#else
-  rv = pref_InitDefaults();
-#endif
-  NS_ENSURE_SUCCESS(rv, rv);
+  // In omni.jar case, we load the following prefs:
+  // - jar:$gre/omni.jar!/greprefs.js
+  // - jar:$gre/omni.jar!/defaults/pref/*.js
+  // In non omni.jar case, we load:
+  // - $gre/greprefs.js
+  //
+  // When $app == $gre, we additionally load, in all cases:
+  // - $gre/defaults/pref/*.js
+  // This is kept for bug 591866 (channel-prefs.js should not be in omni.jar).
+  // We load all files instead of channel-prefs.js only to have the same
+  // behaviour as $app != $gre.
+  //
+  // When $app != $gre, we additionally load, in omni.jar case:
+  // - jar:$app/omni.jar!/defaults/preferences/*.js
+  // - $app/defaults/preferences/*.js
+  // and in non omni.jar case:
+  // - $app/defaults/preferences/*.js
 
-  nsCOMPtr<nsIFile> defaultPrefDir;
-  // now parse the "application" default preferences
-  rv = NS_GetSpecialDirectory(NS_APP_PREF_DEFAULTS_50_DIR, getter_AddRefs(defaultPrefDir));
-  NS_ENSURE_SUCCESS(rv, rv);
+  nsZipFind *findPtr;
+  nsAutoPtr<nsZipFind> find;
+  nsTArray<nsCString> prefEntries;
+  const char *entryName;
+  PRUint16 entryNameLen;
 
-  /* these pref file names should not be used: we process them after all other application pref files for backwards compatibility */
-  static const char* specialFiles[] = {
+  nsZipArchive* jarReader = mozilla::Omnijar::GetReader(mozilla::Omnijar::GRE);
+  if (jarReader) {
+    // Load jar:$gre/omni.jar!/greprefs.js
+    rv = pref_ReadPrefFromJar(jarReader, "greprefs.js");
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    // Load jar:$gre/omni.jar!/defaults/pref/*.js
+    rv = jarReader->FindInit("defaults/pref/*.js$", &findPtr);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    find = findPtr;
+    while (NS_SUCCEEDED(find->FindNext(&entryName, &entryNameLen))) {
+      prefEntries.AppendElement(Substring(entryName, entryName + entryNameLen));
+    }
+
+    prefEntries.Sort();
+    for (PRUint32 i = prefEntries.Length(); i--; ) {
+      rv = pref_ReadPrefFromJar(jarReader, prefEntries[i].get());
+      if (NS_FAILED(rv))
+        NS_WARNING("Error parsing preferences.");
+    }
+  } else {
+    // Load $gre/greprefs.js
+    nsCOMPtr<nsIFile> greprefsFile;
+    rv = NS_GetSpecialDirectory(NS_GRE_DIR, getter_AddRefs(greprefsFile));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = greprefsFile->AppendNative(NS_LITERAL_CSTRING("greprefs.js"));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = openPrefFile(greprefsFile);
+    if (NS_FAILED(rv))
+      NS_WARNING("Error parsing GRE default preferences. Is this an old-style embedding app?");
+  }
+
+  if (!mozilla::Omnijar::HasOmnijar(mozilla::Omnijar::APP)) {
+    // Load $gre/defaults/pref/*.js
+    nsCOMPtr<nsIFile> defaultPrefDir;
+
+    rv = NS_GetSpecialDirectory(NS_APP_PREF_DEFAULTS_50_DIR, getter_AddRefs(defaultPrefDir));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    /* these pref file names should not be used: we process them after all other application pref files for backwards compatibility */
+    static const char* specialFiles[] = {
 #if defined(XP_MAC) || defined(XP_MACOSX)
       "macprefs.js"
 #elif defined(XP_WIN)
       "winpref.js"
 #elif defined(XP_UNIX)
       "unix.js"
-#if defined(_AIX)
+#if defined(VMS)
+      , "openvms.js"
+#elif defined(_AIX)
       , "aix.js"
 #endif
 #elif defined(XP_OS2)
       "os2pref.js"
+#elif defined(XP_BEOS)
+      "beos.js"
 #endif
-  };
+    };
 
-  rv = pref_LoadPrefsInDir(defaultPrefDir, specialFiles, NS_ARRAY_LENGTH(specialFiles));
-  if (NS_FAILED(rv)) {
-    NS_WARNING("Error parsing application default preferences.");
+    rv = pref_LoadPrefsInDir(defaultPrefDir, specialFiles, NS_ARRAY_LENGTH(specialFiles));
+    if (NS_FAILED(rv))
+      NS_WARNING("Error parsing application default preferences.");
+  }
+
+  // Load jar:$app/omni.jar!/defaults/preferences/*.js
+  nsZipArchive *appJarReader = mozilla::Omnijar::GetReader(mozilla::Omnijar::APP);
+  if (appJarReader) {
+    rv = appJarReader->FindInit("defaults/preferences/*.js$", &findPtr);
+    NS_ENSURE_SUCCESS(rv, rv);
+    find = findPtr;
+    prefEntries.Clear();
+    while (NS_SUCCEEDED(find->FindNext(&entryName, &entryNameLen))) {
+      prefEntries.AppendElement(Substring(entryName, entryName + entryNameLen));
+    }
+    prefEntries.Sort();
+    for (PRUint32 i = prefEntries.Length(); i--; ) {
+      rv = pref_ReadPrefFromJar(appJarReader, prefEntries[i].get());
+      if (NS_FAILED(rv))
+        NS_WARNING("Error parsing preferences.");
+    }
   }
 
   rv = pref_LoadPrefsInDirList(NS_APP_PREFS_DEFAULTS_DIR_LIST);
   NS_ENSURE_SUCCESS(rv, rv);
 
   NS_CreateServicesFromCategory(NS_PREFSERVICE_APPDEFAULTS_TOPIC_ID,
                                 nsnull, NS_PREFSERVICE_APPDEFAULTS_TOPIC_ID);
 
diff --git a/netwerk/protocol/res/nsResProtocolHandler.cpp b/netwerk/protocol/res/nsResProtocolHandler.cpp
--- a/netwerk/protocol/res/nsResProtocolHandler.cpp
+++ b/netwerk/protocol/res/nsResProtocolHandler.cpp
@@ -152,97 +152,62 @@ nsResProtocolHandler::nsResProtocolHandl
 }
 
 nsResProtocolHandler::~nsResProtocolHandler()
 {
     gResHandler = nsnull;
 }
 
 nsresult
-nsResProtocolHandler::AddSpecialDir(const char* aSpecialDir, const nsACString& aSubstitution)
-{
-    nsCOMPtr<nsIFile> file;
-    nsresult rv = NS_GetSpecialDirectory(aSpecialDir, getter_AddRefs(file));
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    nsCOMPtr<nsIURI> uri;
-    rv = mIOService->NewFileURI(file, getter_AddRefs(uri));
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    return SetSubstitution(aSubstitution, uri);
-}
-
-nsresult
 nsResProtocolHandler::Init()
 {
     if (!mSubstitutions.Init(32))
         return NS_ERROR_UNEXPECTED;
 
     nsresult rv;
 
     mIOService = do_GetIOService(&rv);
     NS_ENSURE_SUCCESS(rv, rv);
 
-#ifdef MOZ_OMNIJAR
-    nsCOMPtr<nsIFile> omniJar(mozilla::OmnijarPath());
-    if (omniJar)
-        return Init(omniJar);
-#endif
-
-    // these entries should be kept in sync with the omnijar Init function
+    nsCAutoString appURI, greURI;
+    rv = mozilla::Omnijar::GetURIString(mozilla::Omnijar::APP, appURI);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = mozilla::Omnijar::GetURIString(mozilla::Omnijar::GRE, greURI);
+    NS_ENSURE_SUCCESS(rv, rv);
 
     //
-    // make resource:/// point to the application directory
+    // make resource:/// point to the application directory or omnijar
     //
-    rv = AddSpecialDir(NS_OS_CURRENT_PROCESS_DIR, EmptyCString());
+    nsCOMPtr<nsIURI> uri;
+    rv = NS_NewURI(getter_AddRefs(uri), appURI.Length() ? appURI : greURI);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = SetSubstitution(EmptyCString(), uri);
     NS_ENSURE_SUCCESS(rv, rv);
 
     //
     // make resource://gre/ point to the GRE directory
     //
-    rv = AddSpecialDir(NS_GRE_DIR, kGRE);
+    if (appURI.Length()) { // We already have greURI in uri if appURI.Length() is 0.
+        rv = NS_NewURI(getter_AddRefs(uri), greURI);
+        NS_ENSURE_SUCCESS(rv, rv);
+    }
+
+    rv = SetSubstitution(kGRE, uri);
     NS_ENSURE_SUCCESS(rv, rv);
 
     //XXXbsmedberg Neil wants a resource://pchrome/ for the profile chrome dir...
     // but once I finish multiple chrome registration I'm not sure that it is needed
 
     // XXX dveditz: resource://pchrome/ defeats profile directory salting
     // if web content can load it. Tread carefully.
 
     return rv;
 }
 
-#ifdef MOZ_OMNIJAR
-nsresult
-nsResProtocolHandler::Init(nsIFile *aOmniJar)
-{
-    nsresult rv;
-    nsCOMPtr<nsIURI> uri;
-    nsCAutoString omniJarSpec;
-    NS_GetURLSpecFromActualFile(aOmniJar, omniJarSpec, mIOService);
-
-    nsCAutoString urlStr("jar:");
-    urlStr += omniJarSpec;
-    urlStr += "!/";
-
-    rv = mIOService->NewURI(urlStr, nsnull, nsnull, getter_AddRefs(uri));
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    // these entries should be kept in sync with the normal Init function
-
-    // resource:/// points to jar:omni.jar!/
-    SetSubstitution(EmptyCString(), uri);
-
-    // resource://gre/ points to jar:omni.jar!/
-    SetSubstitution(kGRE, uri);
-
-    return NS_OK;
-}
-#endif
-
 #ifdef MOZ_IPC
 static PLDHashOperator
 EnumerateSubstitution(const nsACString& aKey,
                       nsIURI* aURI,
                       void* aArg)
 {
     nsTArray<ResourceMapping>* resources =
             static_cast<nsTArray<ResourceMapping>*>(aArg);
diff --git a/startupcache/StartupCache.cpp b/startupcache/StartupCache.cpp
--- a/startupcache/StartupCache.cpp
+++ b/startupcache/StartupCache.cpp
@@ -237,27 +237,36 @@ StartupCache::GetBuffer(const char* id, 
     nsZipItemPtr<char> zipItem(mArchive, id, true);
     if (zipItem) {
       *outbuf = zipItem.Forget();
       *length = zipItem.Length();
       return NS_OK;
     } 
   }
 
-#ifdef MOZ_OMNIJAR
-  if (mozilla::OmnijarReader()) {
+  if (mozilla::Omnijar::GetReader(mozilla::Omnijar::APP)) {
     // no need to checksum omnijarred entries
-    nsZipItemPtr<char> zipItem(mozilla::OmnijarReader(), id);
+    nsZipItemPtr<char> zipItem(mozilla::Omnijar::GetReader(mozilla::Omnijar::APP), id);
     if (zipItem) {
       *outbuf = zipItem.Forget();
       *length = zipItem.Length();
       return NS_OK;
     } 
   }
-#endif
+
+  if (mozilla::Omnijar::GetReader(mozilla::Omnijar::GRE)) {
+    // no need to checksum omnijarred entries
+    nsZipItemPtr<char> zipItem(mozilla::Omnijar::GetReader(mozilla::Omnijar::GRE), id);
+    if (zipItem) {
+      *outbuf = zipItem.Forget();
+      *length = zipItem.Length();
+      return NS_OK;
+    } 
+  }
+
   return NS_ERROR_NOT_AVAILABLE;
 }
 
 // Makes a copy of the buffer, client retains ownership of inbuf.
 nsresult
 StartupCache::PutBuffer(const char* id, const char* inbuf, PRUint32 len) 
 {
   WaitOnWriteThread();
diff --git a/toolkit/xre/nsAppRunner.cpp b/toolkit/xre/nsAppRunner.cpp
--- a/toolkit/xre/nsAppRunner.cpp
+++ b/toolkit/xre/nsAppRunner.cpp
@@ -3897,35 +3897,45 @@ XRE_InitCommandLine(int aArgc, char* aAr
   CommandLine::Init(aArgc, canonArgs);
 
   for (int i = 0; i < aArgc; ++i)
       free(canonArgs[i]);
   delete[] canonArgs;
 #endif
 #endif
 
-#ifdef MOZ_OMNIJAR
-  const char *omnijarPath = nsnull;
-  ArgResult ar = CheckArg("omnijar", PR_FALSE, &omnijarPath);
+  const char *path = nsnull;
+  ArgResult ar = CheckArg("grebase", PR_FALSE, &path);
   if (ar == ARG_BAD) {
-    PR_fprintf(PR_STDERR, "Error: argument -omnijar requires an omnijar path\n");
+    PR_fprintf(PR_STDERR, "Error: argument -grebase requires a path argument\n");
     return NS_ERROR_FAILURE;
   }
 
-  if (!omnijarPath)
+  if (!path)
     return rv;
 
-  nsCOMPtr<nsILocalFile> omnijar;
-  rv = NS_NewNativeLocalFile(nsDependentCString(omnijarPath), PR_TRUE,
-                             getter_AddRefs(omnijar));
-  if (NS_SUCCEEDED(rv))
-    mozilla::SetOmnijar(omnijar);
-#endif
-
-  return rv;
+  nsCOMPtr<nsILocalFile> greBase;
+  rv = XRE_GetFileFromPath(path, getter_AddRefs(greBase));
+  if (NS_FAILED(rv))
+    return rv;
+
+  ar = CheckArg("appbase", PR_FALSE, &path);
+  if (ar == ARG_BAD) {
+    PR_fprintf(PR_STDERR, "Error: argument -appbase requires a path argument\n");
+    return NS_ERROR_FAILURE;
+  }
+
+  nsCOMPtr<nsILocalFile> appBase;
+  if (path) {
+      rv = XRE_GetFileFromPath(path, getter_AddRefs(appBase));
+      if (NS_FAILED(rv))
+        return rv;
+  }
+
+  return mozilla::Omnijar::SetBase(greBase, appBase);
 }
 
 nsresult
 XRE_DeinitCommandLine()
 {
   nsresult rv = NS_OK;
 
 #if defined(MOZ_IPC)
diff --git a/toolkit/xre/nsEmbedFunctions.cpp b/toolkit/xre/nsEmbedFunctions.cpp
--- a/toolkit/xre/nsEmbedFunctions.cpp
+++ b/toolkit/xre/nsEmbedFunctions.cpp
@@ -512,19 +512,17 @@ XRE_InitChildProcess(int aArgc,
       }
 
       // Run the UI event loop on the main thread.
       uiMessageLoop.MessageLoop::Run();
 
       // Allow ProcessChild to clean up after itself before going out of
       // scope and being deleted
       process->CleanUp();
-#ifdef MOZ_OMNIJAR
-      mozilla::SetOmnijar(nsnull);
-#endif
+      mozilla::Omnijar::SetBase(nsnull, nsnull);
     }
   }
 
   NS_LogTerm();
   return XRE_DeinitCommandLine();
 }
 
 MessageLoop*
diff --git a/xpcom/build/Makefile.in b/xpcom/build/Makefile.in
--- a/xpcom/build/Makefile.in
+++ b/xpcom/build/Makefile.in
@@ -64,28 +64,25 @@ CSRCS		= \
 		$(NULL)
 
 CPPSRCS		= \
 		$(XPCOM_GLUE_SRC_LCPPSRCS) \
 		$(XPCOM_GLUENS_SRC_LCPPSRCS) \
 		nsXPComInit.cpp \
 		nsXPCOMStrings.cpp \
 		Services.cpp \
+		Omnijar.cpp \
 		$(NULL)
 
 ifndef MOZ_ENABLE_LIBXUL
 ifeq (,$(filter-out WINNT WINCE OS2,$(OS_ARCH)))
 CPPSRCS += dlldeps.cpp
 endif
 endif
 
-ifdef MOZ_OMNIJAR
-CPPSRCS += Omnijar.cpp
-endif
-
 SHARED_LIBRARY_LIBS = \
 		$(DEPTH)/chrome/src/$(LIB_PREFIX)chrome_s.$(LIB_SUFFIX) \
 		../ds/$(LIB_PREFIX)xpcomds_s.$(LIB_SUFFIX) \
 		../io/$(LIB_PREFIX)xpcomio_s.$(LIB_SUFFIX) \
 		../components/$(LIB_PREFIX)xpcomcomponents_s.$(LIB_SUFFIX) \
 		../threads/$(LIB_PREFIX)xpcomthreads_s.$(LIB_SUFFIX) \
 		../proxy/src/$(LIB_PREFIX)xpcomproxy_s.$(LIB_SUFFIX) \
 		../base/$(LIB_PREFIX)xpcombase_s.$(LIB_SUFFIX) \
diff --git a/xpcom/build/Omnijar.cpp b/xpcom/build/Omnijar.cpp
--- a/xpcom/build/Omnijar.cpp
+++ b/xpcom/build/Omnijar.cpp
@@ -16,16 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Mozilla Foundation.
  * Portions created by the Initial Developer are Copyright (C) 2010
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Michael Wu <mwu@mozilla.com>
+ *   Mike Hommey <mh@glandium.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -33,69 +34,175 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "Omnijar.h"
 
-#include "nsILocalFile.h"
-#include "nsXULAppAPI.h"
+#include "nsIFile.h"
 #include "nsZipArchive.h"
+#include "nsNetUtil.h"
 
-static nsILocalFile* sOmnijarPath = nsnull;
-static nsZipArchive* sOmnijarReader = nsnull;
+namespace mozilla {
 
-static void
-SetupReader()
+nsIFile *Omnijar::sPath[2] = { nsnull, nsnull };
+PRBool Omnijar::sIsOmnijar[2] = { PR_FALSE, PR_FALSE };
+
+#ifdef MOZ_ENABLE_LIBXUL
+nsZipArchive *Omnijar::sReader[2] = { nsnull, nsnull };
+#endif
+
+static already_AddRefed<nsIFile>
+ComputePath(nsIFile *aPath, PRBool &aIsOmnijar)
 {
-    if (!sOmnijarPath) {
-        return;
+    PRBool isDir;
+    aIsOmnijar = PR_FALSE;
+    if (!aPath || NS_FAILED(aPath->IsDirectory(&isDir)) || !isDir)
+        return nsnull;
+
+    nsCOMPtr<nsIFile> path;
+#ifdef MOZ_ENABLE_LIBXUL
+    // Search for omni.jar in the given directory
+    if (!isDir || NS_FAILED(aPath->Clone(getter_AddRefs(path))))
+        return nsnull;
+
+    if (NS_FAILED(path->AppendNative(NS_LITERAL_CSTRING("omni.jar"))))
+        return nsnull;
+
+    if (NS_FAILED(path->Exists(&aIsOmnijar)))
+        return nsnull;
+#endif
+
+    if (!aIsOmnijar && NS_FAILED(aPath->Clone(getter_AddRefs(path))))
+        return nsnull;
+
+    return path.forget();
+}
+
+nsresult
+Omnijar::SetBase(nsIFile *aGrePath, nsIFile *aAppPath)
+{
+    NS_ABORT_IF_FALSE(aGrePath || !aAppPath, "Omnijar::SetBase(NULL, something) call forbidden");
+
+#ifdef MOZ_ENABLE_LIBXUL
+    if (sReader[GRE]) {
+        sReader[GRE]->CloseArchive();
+        delete sReader[GRE];
+    }
+    if (sReader[APP]) {
+        sReader[APP]->CloseArchive();
+        delete sReader[APP];
+    }
+    sReader[APP] = sReader[GRE] = nsnull;
+#endif
+
+    nsresult rv;
+    PRBool equals;
+    if (aAppPath) {
+        rv = aAppPath->Equals(aGrePath, &equals);
+        NS_ENSURE_SUCCESS(rv, rv);
+    } else {
+        equals = PR_TRUE;
     }
 
-    nsZipArchive* zipReader = new nsZipArchive();
-    if (!zipReader) {
-        NS_IF_RELEASE(sOmnijarPath);
-        return;
+    nsCOMPtr<nsIFile> grePath = ComputePath(aGrePath, sIsOmnijar[GRE]);
+    nsCOMPtr<nsIFile> appPath = ComputePath(equals ? nsnull : aAppPath, sIsOmnijar[APP]);
+
+    NS_IF_RELEASE(sPath[GRE]);
+    sPath[GRE] = grePath;
+    NS_IF_ADDREF(sPath[GRE]);
+
+    NS_IF_RELEASE(sPath[APP]);
+    sPath[APP] = appPath;
+    NS_IF_ADDREF(sPath[APP]);
+
+    return NS_OK;
+}
+
+already_AddRefed<nsIFile>
+Omnijar::GetBase(Type aType)
+{
+    NS_ABORT_IF_FALSE(sPath[0], "Omnijar not initialized");
+
+    if (!sIsOmnijar[aType]) {
+        NS_IF_ADDREF(sPath[aType]);
+        return sPath[aType];
     }
 
-    if (NS_FAILED(zipReader->OpenArchive(sOmnijarPath))) {
+    nsCOMPtr<nsIFile> file, path;
+    if (NS_FAILED(sPath[aType]->Clone(getter_AddRefs(file))))
+        return nsnull;
+
+    if (NS_FAILED(file->GetParent(getter_AddRefs(path))))
+        return nsnull;
+    return path.forget();
+}
+
+#ifdef MOZ_ENABLE_LIBXUL
+nsZipArchive *
+Omnijar::GetReader(Type aType)
+{
+    if (!sIsOmnijar[aType])
+        return nsnull;
+
+    if (sReader[aType])
+        return sReader[aType];
+
+    nsZipArchive* zipReader = new nsZipArchive();
+    if (!zipReader)
+        return nsnull;
+
+    if (NS_FAILED(zipReader->OpenArchive(sPath[aType]))) {
         delete zipReader;
-        NS_IF_RELEASE(sOmnijarPath);
-        return;
+        return nsnull;
     }
 
-    sOmnijarReader = zipReader;
+    return (sReader[aType] = zipReader);
 }
 
-nsILocalFile*
-mozilla::OmnijarPath()
+nsZipArchive *
+Omnijar::GetReader(nsIFile *aPath)
 {
-    if (!sOmnijarReader)
-        SetupReader();
+    PRBool equals;
+    nsresult rv;
 
-    return sOmnijarPath;
+    if (sIsOmnijar[GRE]) {
+        rv = sPath[GRE]->Equals(aPath, &equals);
+        if (NS_SUCCEEDED(rv) && equals)
+            return GetReader(GRE);
+    }
+    if (sIsOmnijar[APP]) {
+        rv = sPath[APP]->Equals(aPath, &equals);
+        if (NS_SUCCEEDED(rv) && equals)
+            return GetReader(APP);
+    }
+    return nsnull;
+}
+#endif
+
+nsresult
+Omnijar::GetURIString(Type aType, nsCString &result)
+{
+    NS_ABORT_IF_FALSE(sPath[0], "Omnijar not initialized");
+
+    result = "";
+
+    if ((aType == APP) && (!sPath[APP]))
+        return NS_OK;
+
+    nsCAutoString omniJarSpec;
+    nsresult rv = NS_GetURLSpecFromActualFile(sPath[aType], omniJarSpec);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    if (sIsOmnijar[aType]) {
+        result = "jar:";
+        result += omniJarSpec;
+        result += "!";
+    } else {
+        result = omniJarSpec;
+    }
+    result += "/";
+    return NS_OK;
 }
 
-nsZipArchive*
-mozilla::OmnijarReader()
-{
-    if (!sOmnijarReader)
-        SetupReader();
-
-    return sOmnijarReader;
-}
-
-void
-mozilla::SetOmnijar(nsILocalFile* aPath)
-{
-    NS_IF_RELEASE(sOmnijarPath);
-    if (sOmnijarReader) {
-        sOmnijarReader->CloseArchive();
-        delete sOmnijarReader;
-        sOmnijarReader = nsnull;
-    }
-
-    sOmnijarPath = aPath;
-    NS_IF_ADDREF(sOmnijarPath);
-}
-
+} /* namespace mozilla */
diff --git a/xpcom/build/Omnijar.h b/xpcom/build/Omnijar.h
--- a/xpcom/build/Omnijar.h
+++ b/xpcom/build/Omnijar.h
@@ -16,16 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Mozilla Foundation.
  * Portions created by the Initial Developer are Copyright (C) 2010
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Michael Wu <mwu@mozilla.com>
+ *   Mike Hommey <mh@glandium.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -34,29 +35,137 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef mozilla_Omnijar_h
 #define mozilla_Omnijar_h
 
-class nsILocalFile;
+#include "nscore.h"
+#include "nsTArray.h"
+#include "nsCOMPtr.h"
+#include "nsString.h"
+
+class nsIFile;
 class nsZipArchive;
-
-#ifdef MOZ_OMNIJAR
+class nsIURI;
 
 namespace mozilla {
 
+#ifdef MOZ_ENABLE_LIBXUL
+#define OMNIJAR_EXPORT
+#else
+#define OMNIJAR_EXPORT NS_EXPORT
+#endif
+
+class OMNIJAR_EXPORT Omnijar {
+private:
 /**
- * This returns the path to the omnijar.
- * If the omnijar isn't available, this function will return null.
- * Callers should fallback to flat packaging if null.
+ * Store an nsIFile for either a base directory when there is no omni.jar,
+ * or omni.jar itself. We can store two paths here, one for GRE
+ * (corresponding to resource://gre/) and one for APP
+ * (corresponding to resource:/// and resource://app/), but only
+ * store one when both point to the same location (unified).
  */
-nsILocalFile *OmnijarPath();
-nsZipArchive *OmnijarReader();
-void SetOmnijar(nsILocalFile* aPath);
+static nsIFile *sPath[2];
+/**
+ * Store whether the corresponding sPath is an omni.jar or a directory
+ */
+static PRBool sIsOmnijar[2];
+
+#ifdef MOZ_ENABLE_LIBXUL
+/**
+ * Cached nsZipArchives for the corresponding sPath
+ */
+static nsZipArchive *sReader[2];
+#endif
+
+public:
+enum Type {
+    GRE = 0,
+    APP = 1
+};
+
+/**
+ * Returns whether SetBase has been called at least once with
+ * a valid nsIFile
+ */
+static PRBool
+IsInitialized()
+{
+    // GRE path is always set after initialization.
+    return sPath[0] != nsnull;
+}
+
+/**
+ * Sets the base directories for GRE and APP. APP base directory
+ * may be nsnull, in case the APP and GRE directories are the same.
+ */
+static nsresult SetBase(nsIFile *aGrePath, nsIFile *aAppPath);
+
+/**
+ * Returns an nsIFile pointing to the omni.jar file for GRE or APP.
+ * Returns nsnull when there is no corresponding omni.jar.
+ * Also returns nsnull for APP in the unified case.
+ */
+static already_AddRefed<nsIFile>
+GetPath(Type aType)
+{
+    NS_ABORT_IF_FALSE(sPath[0], "Omnijar not initialized");
+
+    if (sIsOmnijar[aType]) {
+        NS_IF_ADDREF(sPath[aType]);
+        return sPath[aType];
+    }
+    return nsnull;
+}
+
+/**
+ * Returns whether GRE or APP use an omni.jar. Returns PR_False when
+ * using an omni.jar in the unified case.
+ */
+static PRBool
+HasOmnijar(Type aType)
+{
+    return sIsOmnijar[aType];
+}
+
+/**
+ * Returns the base directory for GRE or APP. In the unified case,
+ * returns nsnull for APP.
+ */
+static already_AddRefed<nsIFile> GetBase(Type aType);
+
+/**
+ * Returns a nsZipArchive pointer for the omni.jar file for GRE or
+ * APP. Returns nsnull in the same cases GetPath() would.
+ */
+#ifdef MOZ_ENABLE_LIBXUL
+static nsZipArchive *GetReader(Type aType);
+#else
+static nsZipArchive *GetReader(Type aType) { return nsnull; }
+#endif
+
+/**
+ * Returns a nsZipArchive pointer for the given path IAOI the given
+ * path is the omni.jar for either GRE or APP.
+ */
+#ifdef MOZ_ENABLE_LIBXUL
+static nsZipArchive *GetReader(nsIFile *aPath);
+#else
+static nsZipArchive *GetReader(nsIFile *aPath) { return nsnull; }
+#endif
+
+/**
+ * Returns the URI string corresponding to the omni.jar or directory
+ * for GRE or APP. i.e. jar:/path/to/omni.jar!/ for omni.jar and
+ * /path/to/base/dir/ otherwise. Returns an empty string for APP in
+ * the unified case.
+ * The returned URI is guaranteed to end with a slash.
+ */
+static nsresult GetURIString(Type aType, nsCString &result);
+
+}; /* class Omnijar */
 
 } /* namespace mozilla */
 
-#endif /* MOZ_OMNIJAR */
-
 #endif /* mozilla_Omnijar_h */
diff --git a/xpcom/build/nsXPComInit.cpp b/xpcom/build/nsXPComInit.cpp
--- a/xpcom/build/nsXPComInit.cpp
+++ b/xpcom/build/nsXPComInit.cpp
@@ -462,35 +462,35 @@ NS_InitXPCOM2(nsIServiceManager* *result
         nsDirectoryService::gService->Set(NS_XPCOM_LIBRARY_FILE, xpcomLib);
     }
     
     if (appFileLocationProvider) {
         rv = nsDirectoryService::gService->RegisterProvider(appFileLocationProvider);
         if (NS_FAILED(rv)) return rv;
     }
 
-#ifdef MOZ_OMNIJAR
     NS_TIME_FUNCTION_MARK("Next: Omnijar init");
 
-    if (!mozilla::OmnijarPath()) {
-        nsCOMPtr<nsILocalFile> omnijar;
+    if (!mozilla::Omnijar::IsInitialized()) {
+        nsCOMPtr<nsILocalFile> greDir, appDir;
         nsCOMPtr<nsIFile> file;
 
-        rv = NS_ERROR_FAILURE;
         nsDirectoryService::gService->Get(NS_GRE_DIR,
                                           NS_GET_IID(nsIFile),
                                           getter_AddRefs(file));
-        if (file)
-            rv = file->Append(NS_LITERAL_STRING("omni.jar"));
-        if (NS_SUCCEEDED(rv))
-            omnijar = do_QueryInterface(file);
-        if (NS_SUCCEEDED(rv))
-            mozilla::SetOmnijar(omnijar);
+        greDir = do_QueryInterface(file);
+
+        nsDirectoryService::gService->Get(NS_XPCOM_CURRENT_PROCESS_DIR,
+                                          NS_GET_IID(nsIFile),
+                                          getter_AddRefs(file));
+        appDir = do_QueryInterface(file);
+
+        rv = mozilla::Omnijar::SetBase(greDir, appDir);
+        NS_ENSURE_SUCCESS(rv, rv);
     }
-#endif
 
 #ifdef MOZ_IPC
     if ((sCommandLineWasInitialized = !CommandLine::IsInitialized())) {
         NS_TIME_FUNCTION_MARK("Next: IPC command line init");
 
 #ifdef OS_WIN
         CommandLine::Init(0, nsnull);
 #else
@@ -769,18 +769,16 @@ ShutdownXPCOM(nsIServiceManager* servMgr
         sCommandLineWasInitialized = false;
     }
     if (sExitManager) {
         delete sExitManager;
         sExitManager = nsnull;
     }
 #endif
 
-#ifdef MOZ_OMNIJAR
-    mozilla::SetOmnijar(nsnull);
-#endif
+    mozilla::Omnijar::SetBase(nsnull, nsnull);
 
     NS_LogTerm();
 
     return NS_OK;
 }
 
 } // namespace mozilla
diff --git a/xpcom/components/nsComponentManager.cpp b/xpcom/components/nsComponentManager.cpp
--- a/xpcom/components/nsComponentManager.cpp
+++ b/xpcom/components/nsComponentManager.cpp
@@ -175,18 +175,16 @@ NS_DEFINE_CID(kCategoryManagerCID, NS_CA
 #define COMPMGR_TIME_FUNCTION_CONTRACTID(cid)                                  \
   NS_TIME_FUNCTION_MIN_FMT(5, "%s (line %d) (contractid: %s)", MOZ_FUNCTION_NAME, \
                            __LINE__, (cid))
 #else
 #define COMPMGR_TIME_FUNCTION_CID(cid) do {} while (0)
 #define COMPMGR_TIME_FUNCTION_CONTRACTID(cid) do {} while (0)
 #endif
 
-#define kOMNIJAR_PREFIX  NS_LITERAL_CSTRING("resource:///")
-
 nsresult
 nsGetServiceFromCategory::operator()(const nsIID& aIID, void** aInstancePtr) const
 {
     nsresult rv;
     nsXPIDLCString value;
     nsCOMPtr<nsICategoryManager> catman;
     nsComponentManagerImpl *compMgr = nsComponentManagerImpl::gComponentManager;
     if (!compMgr) {
@@ -390,47 +388,44 @@ nsresult nsComponentManagerImpl::Init()
 
     nsCategoryManager::GetSingleton()->SuppressNotifications(true);
 
     RegisterModule(&kXPCOMModule, NULL);
 
     for (PRUint32 i = 0; i < sStaticModules->Length(); ++i)
         RegisterModule((*sStaticModules)[i], NULL);
 
-#ifdef MOZ_OMNIJAR
-    if (mozilla::OmnijarPath()) {
-        nsCOMPtr<nsIZipReader> omnijarReader = new nsJAR();
-        rv = omnijarReader->Open(mozilla::OmnijarPath());
-        if (NS_SUCCEEDED(rv))
-            RegisterJarManifest(omnijarReader, "chrome.manifest", false);
+    nsCOMPtr<nsIFile> appOmnijar = mozilla::Omnijar::GetPath(mozilla::Omnijar::APP);
+    if (appOmnijar) {
+        cl = sModuleLocations->InsertElementAt(1); // Insert after greDir
+        cl->type = NS_COMPONENT_LOCATION;
+        cl->location = do_QueryInterface(appOmnijar);
+        cl->jar = true;
     }
-#endif
+    nsCOMPtr<nsIFile> greOmnijar = mozilla::Omnijar::GetPath(mozilla::Omnijar::GRE);
+    if (greOmnijar) {
+        cl = sModuleLocations->InsertElementAt(0);
+        cl->type = NS_COMPONENT_LOCATION;
+        cl->location = do_QueryInterface(greOmnijar);
+        cl->jar = true;
+    }
 
     for (PRUint32 i = 0; i < sModuleLocations->Length(); ++i) {
         ComponentLocation& l = sModuleLocations->ElementAt(i);
         if (!l.jar) {
             RegisterManifestFile(l.type, l.location, false);
             continue;
         }
 
         nsCOMPtr<nsIZipReader> reader = do_CreateInstance(kZipReaderCID, &rv);
         rv = reader->Open(l.location);
         if (NS_SUCCEEDED(rv))
             RegisterJarManifest(reader, "chrome.manifest", false);
     }
 
-#ifdef MOZ_OMNIJAR
-    if (mozilla::OmnijarPath()) {
-        cl = sModuleLocations->InsertElementAt(0);
-        cl->type = NS_COMPONENT_LOCATION;
-        cl->location = mozilla::OmnijarPath();
-        cl->jar = true;
-    }
-#endif
-
     nsCategoryManager::GetSingleton()->SuppressNotifications(false);
 
     mStatus = NORMAL;
 
     return NS_OK;
 }
 
 void
# HG changeset patch
# Parent ff1b810f78226d7f4010909d3cde05a57fdcf20c
Bug 620931 part 4 - Fix resource://app/ to always point to the same as resource:///

diff --git a/netwerk/protocol/res/nsResProtocolHandler.cpp b/netwerk/protocol/res/nsResProtocolHandler.cpp
--- a/netwerk/protocol/res/nsResProtocolHandler.cpp
+++ b/netwerk/protocol/res/nsResProtocolHandler.cpp
@@ -74,16 +74,17 @@ static nsResProtocolHandler *gResHandler
 //    set NSPR_LOG_FILE=log.txt
 //
 // this enables PR_LOG_ALWAYS level information and places all output in
 // the file log.txt
 //
 static PRLogModuleInfo *gResLog;
 #endif
 
+#define kAPP           NS_LITERAL_CSTRING("app")
 #define kGRE           NS_LITERAL_CSTRING("gre")
 
 //----------------------------------------------------------------------------
 // nsResURL : overrides nsStandardURL::GetFile to provide nsIFile resolution
 //----------------------------------------------------------------------------
 
 nsresult
 nsResURL::EnsureFile()
@@ -179,16 +180,22 @@ nsResProtocolHandler::Init()
     nsCOMPtr<nsIURI> uri;
     rv = NS_NewURI(getter_AddRefs(uri), appURI.Length() ? appURI : greURI);
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = SetSubstitution(EmptyCString(), uri);
     NS_ENSURE_SUCCESS(rv, rv);
 
     //
+    // make resource://app/ point to the application directory or omnijar
+    //
+    rv = SetSubstitution(kAPP, uri);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    //
     // make resource://gre/ point to the GRE directory
     //
     if (appURI.Length()) { // We already have greURI in uri if appURI.Length() is 0.
         rv = NS_NewURI(getter_AddRefs(uri), greURI);
         NS_ENSURE_SUCCESS(rv, rv);
     }
 
     rv = SetSubstitution(kGRE, uri);
diff --git a/toolkit/xre/nsXREDirProvider.cpp b/toolkit/xre/nsXREDirProvider.cpp
--- a/toolkit/xre/nsXREDirProvider.cpp
+++ b/toolkit/xre/nsXREDirProvider.cpp
@@ -300,19 +300,16 @@ nsXREDirProvider::GetFile(const char* aP
     }
   }
   else if (!strcmp(aProperty, XRE_EXECUTABLE_FILE) && gArgv[0]) {
     nsCOMPtr<nsILocalFile> lf;
     rv = XRE_GetBinaryPath(gArgv[0], getter_AddRefs(lf));
     if (NS_SUCCEEDED(rv))
       file = lf;
   }
-  else if (!strcmp(aProperty, "resource:app")) {
-    rv = GetAppDir()->Clone(getter_AddRefs(file));
-  }
 
   else if (!strcmp(aProperty, NS_APP_PROFILE_DIR_STARTUP) && mProfileDir) {
     return mProfileDir->Clone(aFile);
   }
   else if (!strcmp(aProperty, NS_APP_PROFILE_LOCAL_DIR_STARTUP)) {
     if (mProfileLocalDir)
       return mProfileLocalDir->Clone(aFile);
 
# HG changeset patch
# Parent 7d2228db71a299afca60babff632a967d2d6c456
Bug 620931 part 5 - Enable omni.jar by default on xulrunner

diff --git a/xulrunner/confvars.sh b/xulrunner/confvars.sh
--- a/xulrunner/confvars.sh
+++ b/xulrunner/confvars.sh
@@ -36,15 +36,16 @@
 #
 # ***** END LICENSE BLOCK *****
 
 MOZ_APP_NAME=xulrunner
 MOZ_APP_DISPLAYNAME=XULRunner
 MOZ_UPDATER=1
 MOZ_XULRUNNER=1
 MOZ_ENABLE_LIBXUL=1
+MOZ_CHROME_FILE_FORMAT=omni
 MOZ_STATIC_BUILD_UNSUPPORTED=1
 MOZ_APP_VERSION=$MOZILLA_VERSION
 if test "$MOZ_STORAGE"; then
   MOZ_PLACES=1
 fi
 MOZ_EXTENSIONS_DEFAULT=" gnomevfs"
 MOZ_URL_CLASSIFIER=1
